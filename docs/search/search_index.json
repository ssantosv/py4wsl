{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WSL Doc","text":""},{"location":"#wsl.WSL","title":"<code>WSL</code>","text":"Source code in <code>wsl.py</code> <pre><code>class WSL:\n\n    def __init__(self, distro='Ubuntu'):\n        self.distro = distro\n        self._setup_ctypes()\n        self.ole32 = ctypes.WinDLL('ole32')\n\n        self.wslapi.WslRegisterDistribution.argtypes = [\n            ctypes.c_wchar_p,  # distributionName\n            ctypes.c_wchar_p   # tarGzFilename\n        ]\n        self.wslapi.WslRegisterDistribution.restype = ctypes.c_long\n\n        self.wslapi.WslUnregisterDistribution.argtypes = [\n            ctypes.c_wchar_p  # distributionName\n        ]\n        self.wslapi.WslUnregisterDistribution.restype = ctypes.c_long\n\n        self.wslapi.WslIsDistributionRegistered.argtypes = [\n            ctypes.c_wchar_p  # distributionName\n        ]\n        self.wslapi.WslIsDistributionRegistered.restype = wintypes.BOOL\n\n    def _setup_ctypes(self):\n        # Configuraciones existentes...\n\n        # Nueva configuraci\u00f3n para WslConfigureDistribution\n        self.wslapi.WslConfigureDistribution.argtypes = [\n            ctypes.c_wchar_p,          # distributionName\n            ctypes.c_ulong,            # defaultUID\n            ctypes.c_ulong             # wslDistributionFlags (como DWORD)\n        ]\n        self.wslapi.WslConfigureDistribution.restype = ctypes.c_long\n\n        # Configuraci\u00f3n para WslGetDistributionConfiguration\n        self.wslapi.WslGetDistributionConfiguration.argtypes = [\n            ctypes.c_wchar_p,          # distributionName\n            POINTER(ctypes.c_ulong),   # distributionVersion\n            POINTER(ctypes.c_ulong),   # defaultUID\n            POINTER(ctypes.c_ulong),   # wslDistributionFlags\n            POINTER(POINTER(c_char_p)),# defaultEnvironmentVariables\n            POINTER(ctypes.c_ulong)    # defaultEnvironmentVariableCount\n        ]\n        self.wslapi.WslGetDistributionConfiguration.restype = ctypes.c_long\n    def get_distribution_configuration(self):\n        config = {\n            #'name': None,\n            'version': None,\n            'default_uid': None,\n            'flags': None,\n            'env_vars': {}\n        }\n\n\n        version = ctypes.c_ulong()\n        uid = ctypes.c_ulong()\n        flags = ctypes.c_ulong()\n        env_vars = ctypes.POINTER(ctypes.c_wchar_p)()\n        env_count = ctypes.c_ulong()\n\n        hr = self.wslapi.WslGetDistributionConfiguration(\n            self.distro,\n\n            ctypes.byref(version),\n            ctypes.byref(uid),\n            ctypes.byref(flags),\n            ctypes.byref(env_vars),\n            ctypes.byref(env_count)\n        )\n\n        if hr == 0:\n            config['version'] = version.value\n            config['default_uid'] = uid.value\n            config['flags'] = flags.value  \n            if config['flags'] &amp; 0x1: \n                print(\"ENABLE_INTEROP\")\n            if config['flags'] &amp; 0x2:\n                print(\"APPEND_NT_PATH\")\n            if config['flags'] &amp; 0x4:\n                print(\"ENABLE_DRIVE_MOUNTING\")\n            if config['flags'] == 0:\n                print(\"NONE\")\n\n            # Manejar variables de entorno de forma segura\n            for i in range(env_count.value):\n                var = env_vars[i]\n                if var:\n                    key_value = var.split('=', 1)\n                    if len(key_value) == 2:\n                        config['env_vars'][key_value[0]] = key_value[1]\n            # Solo libera el array principal, no cada cadena individual\n            ctypes.windll.ole32.CoTaskMemFree(env_vars)\n\n\n        return config if hr == 0 else None\n\n    def get_wsl_distro_info_by_name(self):\n        \"\"\"\n        Returns a dictionary with the requested data for the WSL distribution whose name matches distro_name.\n        If not found, returns None.\n        \"\"\"\n        key_path = r\"Software\\Microsoft\\Windows\\CurrentVersion\\Lxss\"\n        fields = [\"BasePath\", \"Flavor\", \"PackageFamilyName\", \"Version\", \"osVersion\"]\n        try:\n            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path) as lxss_key:\n                i = 0\n                while True:\n                    try:\n                        guid = winreg.EnumKey(lxss_key, i)\n                        with winreg.OpenKey(lxss_key, guid) as distro_key:\n                            try:\n                                name = winreg.QueryValueEx(distro_key, \"DistributionName\")[0]\n                            except FileNotFoundError:\n                                name = None\n                            if isinstance(name, str) and name.lower() == self.distro.lower():\n                                result = {\n                                    \"BasePath\": None,\n                                    \"Flavor\": None,\n                                    \"GUID\": guid,\n                                    \"osVersion\": None,\n                                    \"PackageFamilyName\": None\n                                }\n                                for field in fields:\n                                    try:\n                                        value = winreg.QueryValueEx(distro_key, field)[0]\n                                        if field.lower() in (\"version\", \"osversion\"):\n                                            result[\"osVersion\"] = value\n                                        else:\n                                            result[field] = value\n                                    except FileNotFoundError:\n                                        continue\n                                return result\n                        i += 1\n                    except OSError:\n                        break\n        except Exception as e:\n            print(f\"Error accediendo al registro: {e}\")\n        return None\n\n\n    def configure_distribution(self, \n                             default_uid: int = None, \n                             flags: WSL_DISTRIBUTION_FLAGS = None):\n        \"\"\"\n\n        Configure the WSL distribution parameters\n\n\n        Args:\n            default_uid (int): Default user UID\n            flags (WSL_DISTRIBUTION_FLAGS): Configuration flags\n\n        \"\"\"\n        current_config = self.get_distribution_configuration()\n\n        # Mantener valores actuales si no se especifican\n        final_uid = default_uid if default_uid is not None else current_config['default_uid']\n        final_flags = flags if flags is not None else current_config['flags']\n\n        hr = self.wslapi.WslConfigureDistribution(\n            self.distro,\n            final_uid,\n            final_flags.value if isinstance(final_flags, WSL_DISTRIBUTION_FLAGS) else final_flags\n        )\n\n        return hr == 0\n\n    def set_distribution_flag(self, flag: WSL_DISTRIBUTION_FLAGS, enable: bool):\n        \"\"\"\"Modify a specific flag while keeping the others unchanged\"\"\"\n        config = self.get_distribution_configuration()\n        if not config:\n            return False\n\n        current_flags = config['flags']\n\n        if enable:\n            new_flags = current_flags | flag\n        else:\n            new_flags = current_flags &amp; ~flag\n\n        return self.configure_distribution(flags=new_flags)\n\n    def register_distribution(self, distribution_name: str, tar_gz_path: str) -&gt; bool:\n        \"\"\"\n       Register a new WSL distribution.\n\n        Args:\n        distribution_name: Unique name of the distribution (e.g., \"MyDistro\")\n        tar_gz_path: Full path to the .tar.gz file containing the filesystem\n\n        Returns:\n        bool: True if registration was successful, False if it faileda\n        \"\"\"\n        hr = self.wslapi.WslRegisterDistribution(distribution_name, tar_gz_path)\n        return hr == 0  # S_OK = 0\n\n    def unregister_distribution(self, distribution_name: str) -&gt; bool:\n        \"\"\"\n        Unregister a WSL distribution.\n\n        Args:\n            distribution_name: Name of the distribution to remove\n        Returns:\n            bool: True if the operation was successful\n        \"\"\"\n        hr = self.wslapi.WslUnregisterDistribution(distribution_name)\n        return hr == 0  # S_OK = 0\n\n    def is_distribution_registered(self, distribution_name: str) -&gt; bool:\n        \"\"\"\n        Checks if a distribution is registered.\n\n        Args:\n        distribution_name: Name of the distribution to check\n\n        Returns:\n        bool: True if the distribution is registered\n        \"\"\"\n        return bool(self.wslapi.WslIsDistributionRegistered(distribution_name))\n\n    def _setup_ctypes(self):\n        self.wslapi = ctypes.WinDLL(\"wslapi.dll\")\n        self.kernel32 = ctypes.WinDLL(\"kernel32\", use_last_error=True)\n\n        # Configurar WslLaunch\n        self.wslapi.WslLaunch.argtypes = [\n            ctypes.c_wchar_p,\n            ctypes.c_wchar_p,\n            wintypes.BOOL,\n            wintypes.HANDLE,\n            wintypes.HANDLE,\n            wintypes.HANDLE,\n            ctypes.POINTER(wintypes.HANDLE)\n        ]\n        self.wslapi.WslLaunch.restype = ctypes.c_long\n\n        # Configurar funciones de kernel32\n        self._configure_kernel32_functions()\n\n    def launch_interactive(self, command: str = None, use_current_working_directory: bool = True) -&gt; dict:\n        \"\"\"\n        Ejecuta un comando interactivo usando WslLaunchInteractive.\n\n            Args:\n                command (str, optional): Command to execute. If None, launches the default shell.\n                use_current_working_directory (bool): Use the current working directory of the calling process.\n\n            Returns:\n                dict: {\n                \"hr\": HRESULT,\n                \"exit_code\": int (only if hr == 0)\n                }\n        \"\"\"\n        exit_code = wintypes.DWORD()\n\n        hr = self.wslapi.WslLaunchInteractive(\n            self.distro,\n            command,\n            use_current_working_directory,\n            ctypes.byref(exit_code)\n        )\n\n        return {\n            \"hr\": hr,\n            \"exit_code\": exit_code.value if hr == 0 else None\n        }\n\n    def _configure_kernel32_functions(self):\n        \"\"\"Configura las funciones de la API de Windows\"\"\"\n        self.kernel32.CreatePipe.argtypes = [\n            ctypes.POINTER(wintypes.HANDLE),\n            ctypes.POINTER(wintypes.HANDLE),\n            ctypes.POINTER(SECURITY_ATTRIBUTES),\n            wintypes.DWORD\n        ]\n        self.kernel32.CreatePipe.restype = wintypes.BOOL\n\n        self.kernel32.ReadFile.argtypes = [\n            wintypes.HANDLE,\n            ctypes.c_void_p,\n            wintypes.DWORD,\n            ctypes.POINTER(wintypes.DWORD),\n            ctypes.POINTER(OVERLAPPED)\n        ]\n        self.kernel32.ReadFile.restype = wintypes.BOOL\n\n        self.kernel32.CloseHandle.argtypes = [wintypes.HANDLE]\n        self.kernel32.CloseHandle.restype = wintypes.BOOL\n\n        self.kernel32.WaitForSingleObject.argtypes = [wintypes.HANDLE, wintypes.DWORD]\n        self.kernel32.WaitForSingleObject.restype = wintypes.DWORD\n\n        self.kernel32.GetExitCodeProcess.argtypes = [wintypes.HANDLE, ctypes.POINTER(wintypes.DWORD)]\n        self.kernel32.GetExitCodeProcess.restype = wintypes.BOOL\n\n\n    def _create_pipe(self):\n        \"\"\"Create an anonymous pipe with handle inheritance\"\"\"\n        sa = SECURITY_ATTRIBUTES()\n        sa.nLength = ctypes.sizeof(SECURITY_ATTRIBUTES)\n        sa.lpSecurityDescriptor = None\n        sa.bInheritHandle = True\n\n        read_handle = wintypes.HANDLE()\n        write_handle = wintypes.HANDLE()\n\n        if not self.kernel32.CreatePipe(\n            ctypes.byref(read_handle),\n            ctypes.byref(write_handle),\n            ctypes.byref(sa),\n            0\n        ):\n            raise ctypes.WinError(ctypes.get_last_error())\n\n        return read_handle, write_handle\n\n    def _read_pipe_async(self, handle):\n        \"\"\"Read data from a pipe asynchronously.\"\"\"\n        buffer = ctypes.create_string_buffer(4096)\n        bytes_read = wintypes.DWORD()\n        overlapped = OVERLAPPED()\n        output = b\"\"\n\n        while True:\n            success = self.kernel32.ReadFile(\n                handle,\n                buffer,\n                ctypes.sizeof(buffer),\n                ctypes.byref(bytes_read),\n                ctypes.byref(overlapped)\n            )\n\n            if not success and ctypes.get_last_error() != 997:  # ERROR_IO_PENDING\n                break\n\n            self.kernel32.GetOverlappedResult(handle, ctypes.byref(overlapped), ctypes.byref(bytes_read), True)\n            if bytes_read.value == 0:\n                break\n\n            output += buffer[:bytes_read.value]\n\n        return output\n\n    def _launch_process(self, command):\n        \"\"\"Execute a command using the native API with timeout handling.\"\"\"\n        stdout_read, stdout_write = self._create_pipe()\n        stderr_read, stderr_write = self._create_pipe()\n        process_handle = wintypes.HANDLE()\n\n        try:\n            # Lanzar proceso\n            hr = self.wslapi.WslLaunch(\n                self.distro,\n                command,\n                True,\n                wintypes.HANDLE(0),\n                stdout_write,\n                stderr_write,\n                ctypes.byref(process_handle)\n            )\n\n            if hr != 0:\n                return {\"hr\": hr, \"stdout\": b\"\", \"stderr\": b\"\", \"exit_code\": 1}\n\n            # Cerrar extremos de escritura\n            self.kernel32.CloseHandle(stdout_write)\n            self.kernel32.CloseHandle(stderr_write)\n\n            # Leer salida en hilos separados\n            stdout_buffer = []\n            stderr_buffer = []\n\n            stdout_thread = threading.Thread(\n                target=lambda: stdout_buffer.append(self._read_pipe_async(stdout_read))\n            )\n            stderr_thread = threading.Thread(\n                target=lambda: stderr_buffer.append(self._read_pipe_async(stderr_read))\n            )\n\n            stdout_thread.start()\n            stderr_thread.start()\n\n            # Esperar proceso con timeout\n            exit_code = self._wait_for_process(process_handle)\n\n            # Esperar hilos\n            stdout_thread.join()\n            stderr_thread.join()\n\n            return {\n                \"hr\": 0,\n                \"stdout\": stdout_buffer[0] if stdout_buffer else b\"\",\n                \"stderr\": stderr_buffer[0] if stderr_buffer else b\"\",\n                \"exit_code\": exit_code\n            }\n\n        finally:\n            # Limpieza de handles\n            handles = [stdout_read, stderr_read, process_handle]\n            for handle in handles:\n                if handle:\n                    self.kernel32.CloseHandle(handle)\n\n    def _wait_for_process(self, process_handle, timeout=30000):\n        \"\"\"Wait for the process to finish with a maximum timeout.\"\"\"\n        result = self.kernel32.WaitForSingleObject(process_handle, timeout)\n\n        if result == 0x00000000:  # WAIT_OBJECT_0\n            exit_code = wintypes.DWORD()\n            self.kernel32.GetExitCodeProcess(process_handle, ctypes.byref(exit_code))\n            return exit_code.value\n        elif result == 0x00000102:  # WAIT_TIMEOUT\n            self.kernel32.TerminateProcess(process_handle, 1)\n            return -1\n        else:\n            return -2\n\n    # ==============================================\n    # M\u00e9todos p\u00fablicos\n    # ==============================================\n    def launch(self, command: str, capture_output: bool = True) -&gt; dict:\n        \"\"\"Execute a command using the native api\"\"\"\n        result = self._launch_process(command)\n        return {\n            \"stdout\": result[\"stdout\"].decode(\"utf-8\", errors=\"replace\") if capture_output else \"\",\n            \"stderr\": result[\"stderr\"].decode(\"utf-8\", errors=\"replace\") if capture_output else \"\",\n            \"exit_code\": result[\"exit_code\"]\n        }\n    def run_command(self, command, capture_output=True, shell=False,input=None):\n        \"\"\"Execute a command using subprocess\"\"\"\n        base_cmd = ['wsl.exe', '-d', self.distro]\n\n        try:\n            if shell:\n                full_cmd = base_cmd + ['/bin/bash', '-c', command]\n                args = ' '.join(full_cmd)\n                print(full_cmd)\n            else:\n                args = base_cmd + shlex.split(command)\n                print(command)\n\n            result = subprocess.run(\n                args,\n                input=input,\n                capture_output=capture_output,\n                text=True,\n                check=True,\n                shell=False\n            )\n\n            return {\n                \"stdout\": result.stdout,\n                \"stderr\": result.stderr,\n                \"exit_code\": result.returncode,\n\n            }\n\n        except subprocess.CalledProcessError as e:\n            return {\n                \"stdout\": e.stdout,\n                \"stderr\": e.stderr,\n                \"exit_code\": e.returncode\n            }\n    # ========================\n    # Funciones de administraci\u00f3n\n    # ========================\n\n    def parse_wsl_conf(self):\n        raw_content = self.read_wsl_conf()\n        if isinstance(raw_content, dict):\n            # Ya est\u00e1 parseado, simplemente retorna\n            return raw_content\n        # Si es string, entonces lo analizas l\u00ednea a l\u00ednea\n        config = {\n            'automount': {},\n            'network': {},\n            'interop': {},\n            'user': {},\n            'boot': {},\n            'useWindowsTimezone':{},\n            'systemd': {}\n        }\n        current_section = None\n        for line in raw_content.split('\\n'):\n            line = line.strip()\n            if line.startswith('#') or not line:\n                continue\n            if line.startswith('[') and line.endswith(']'):\n                current_section = line[1:-1].lower()\n                continue\n            if '=' in line and current_section:\n                key, value = line.split('=', 1)\n                key = key.strip().lower()\n                value = value.strip()\n                if value.lower() in ('true', 'false'):\n                    value = value.lower() == 'true'\n                if current_section in config:\n                    config[current_section][key] = value\n        return config\n\n    def install_package(self, package, password):\n        \"\"\"Install a package using sudo\"\"\"\n        return self.run_command(\n            f\"sudo -S apt-get install -y {package}\",\n            input=f\"{password}\\n\",\n            shell=False\n        )\n\n\n    def is_interop_enabled(self):\n        \"\"\"Returns True if interoperatibility is enabled\"\"\"\n        conf = self.parse_wsl_conf()\n        return conf.get('interop', {}).get('enabled', True)  \n\n    def is_systemd_enabled(self):\n        \"\"\"Returns True if systemd is enabled\"\"\"\n        conf = self.parse_wsl_conf()\n        return conf.get('systemd', {}).get('enabled', True)  \n\n    def is_useWindowsTimezone_enabled(self):\n        \"\"\"Returns True if useWindowsTimezone is enabled\"\"\"\n        conf = self.parse_wsl_conf()\n        return conf.get('useWindowsTimezone', {}).get('enabled', True)  \n\n    def get_network_config(self):\n        \"\"\"Returns network configuration in dict format\"\"\"\n        conf = self.parse_wsl_conf()\n        return {\n            'hostname': conf.get('network', {}).get('hostname'),\n            'generate_hosts': conf.get('network', {}).get('generatehosts', True),\n            'generate_resolvconf': conf.get('network', {}).get('generateresolvconf', True)\n        }\n\n    def get_automount_settings(self):\n        \"\"\"Returns mount config\"\"\"\n        conf = self.parse_wsl_conf()\n        return {\n            'enabled': conf.get('automount', {}).get('enabled', True),\n            'root': conf.get('automount', {}).get('root', '/mnt'),\n            'options': conf.get('automount', {}).get('options', '')\n        }\n\n    def get_default_user(self):\n        \"\"\"Returns default user\"\"\"\n        return self.parse_wsl_conf().get('user', {}).get('default')\n\n    def read_wsl_conf(self, output_format='raw'):\n        \"\"\"Reads /etc/wsl.conf\"\"\"\n        return self._launch_process(\"cat /etc/wsl.conf\")\n\n\n    def list_installed_packages(self):\n        \"\"\"List installed packages\"\"\"\n        commands = [\n        (\"apt\", \"apt list\"),\n        (\"dnf\", \"dnf list installed\"),\n        (\"yum\", \"yum list installed\"),\n        (\"zypper\", \"zypper se --installed-only\"),\n    ]\n        for name, cmd in commands:\n        # Verifica si el gestor de paquetes est\u00e1 disponible\n            check = self.run_command(f\"which {name}\")\n            if isinstance(check, dict):\n                found = bool(check.get('stdout', '').strip())\n            else:\n                found = bool(check.strip())\n            if not found:\n                continue  # El gestor no est\u00e1 presente, prueba el siguiente\n\n            # Ejecuta el comando para listar paquetes\n            result = self.run_command(cmd)\n            output = result.get('stdout', '') if isinstance(result, dict) else result\n            if output:\n                return output.splitlines()\n\n        # Si ninguno est\u00e1 disponible, retorna una lista vac\u00eda\n        return []\n\n    # ========================\n    # Funciones de configuraci\u00f3n Windows\n    # ========================\n    def read_wslconfig(self):\n        \"\"\"Read .wslconfig\"\"\"\n        path = os.path.expanduser(\"~/.wslconfig\")\n\n        try:\n            with open(path, \"r\") as f:\n                return f.read()\n        except Exception as e:\n            print(f\"Error leyendo {path}: {e}\")\n            return None\n\n    def parse_wslconfig(self):\n        \"\"\"Analyzes .wslconfig and return dictionary\"\"\"\n        raw_content = self.read_wslconfig()  # Debe devolver el texto plano del archivo\n        config = {\n            'wsl2': {}\n        }\n        current_section = None\n        for line in raw_content.split('\\n'):\n            line = line.strip()\n            if line.startswith('#') or not line:\n                continue\n            if line.startswith('[') and line.endswith(']'):\n                current_section = line[1:-1].lower()\n                continue\n            if '=' in line and current_section:\n                key, value = line.split('=', 1)\n                key = key.strip().lower()\n                value = value.strip()\n                # Convertir booleanos\n                if value.lower() in ('true', 'false'):\n                    value = value.lower() == 'true'\n                # Convertir n\u00fameros si corresponde\n                elif value.isdigit():\n                    value = int(value)\n                if current_section in config:\n                    config[current_section][key] = value\n        return config\n\n    def wsl2_memory(self):\n        \"\"\"Returns memory limit in WSL2 or None\"\"\"\n        conf = self.parse_wslconfig()\n        return conf.get('wsl2', {}).get('memory')\n\n    def wsl2_processors(self):\n        \"\"\"Returns processors in WSL2 o None\"\"\"\n        conf = self.parse_wslconfig()\n        return conf.get('wsl2', {}).get('processors')\n\n    def wsl2_swap(self):\n        \"\"\"Returns swap size in WSL2 o None\"\"\"\n        conf = self.parse_wslconfig()\n        return conf.get('wsl2', {}).get('swap')\n\n    def wsl2_localhost_forwarding(self):\n        \"\"\"Returns True/False for localhostForwarding in WSL2\"\"\"\n        conf = self.parse_wslconfig()\n        return conf.get('wsl2', {}).get('localhostforwarding', True)  # True por defecto\n\n    def wsl2_gui_applications(self):\n        \"\"\"Devuelve True/False seg\u00fan la opci\u00f3n guiApplications de WSL2\"\"\"\n        conf = self.parse_wslconfig()\n        return conf.get('wsl2', {}).get('guiapplications', True)  # True por defecto\n\n\n    # ========================\n    # Funciones de mantenimiento\n    # ========================\n    def wsl_access_dates(self):\n        return self.run_command(\"stat /\")\n\n\n    # ========================\n    # Funciones de keep alive\n    # ========================\n    def stop_keep_alive(self):\n        self.launch(\"pkill -f nosleep.sh\")\n\n\n    def keep_alive(self):\n\n        nuevo_fichero = \"\"\"\n#!/bin/sh\nwhile true\ndo\nsleep 1s\ndone\n\"\"\"\n        current_dir = os.getcwd()\n        script_path = os.path.join(current_dir, \"nosleep.sh\")\n        with open(script_path, \"w\", encoding=\"utf-8\",newline='\\n') as f:\n            f.write(nuevo_fichero)\n\n        wsl_user = str(self.launch('whoami')[\"stdout\"]).strip()\n\n        wsl_dest = f\"/home/{wsl_user}/nosleep.sh\"\n        self.copy_to_wsl(f\"nosleep.sh\",wsl_dest)        \n        self.launch(f\"chmod +x '{wsl_dest}'\")\n        self.launch(f\"tmux new-session -d '{wsl_dest}'\")\n\n    # ========================\n    # Funciones de archivo\n    # ========================\n    def copy_to_wsl(self, origin, dest, distro=\"Ubuntu\"):\n        \"\"\"\n        Copies a Windows file (origin) to a destination path (dest) in the specified WSL distribution.\n        - origin: Absolute path in Windows \n        - dest: Absolute path in Linux (e.g., /home/user/file.txt)\n        - distro: Name of the WSL distribution (default 'Ubuntu')\n\n        \"\"\"\n        #Paso 1: Convertir la ruta destino de Linux a ruta Windows usando wslpath\n        print(dest)\n        try:\n             result = subprocess.run(\n                 [\"wsl\", \"-d\", distro, \"wslpath\", \"-w\", dest],\n                 capture_output=True,\n                 text=True,\n                 check=True\n             )\n             dest_win = result.stdout.strip()\n             if not dest:\n                 raise RuntimeError(\"La conversi\u00f3n de ruta\u00ba no devolvi\u00f3 resultado.\")\n        except subprocess.CalledProcessError as e:\n             raise RuntimeError(f\"Error ejecutando wslpath: {e.stderr.strip()}\") from e\n        except Exception as e:\n             raise RuntimeError(f\"Error inesperado al convertir la ruta: {e}\") from e\n\n\n\n        # Paso 3: Copiar el archivo\n        try:\n            shutil.copy2(origin, dest_win)\n\n            return True\n        except Exception as e:\n            raise RuntimeError(f\"Error copiando el archivo: {e}\") from e\n\n\n    def copy_from_wsl(self, origin, dest, distro=\"Ubuntu\"):\n        \"\"\"\n        Copies a file from a path in WSL (origin, Linux) to a destination path in Windows (dest).\n        - origin: Absolute path in Linux (e.g., /home/user/file.txt)\n        - dest: Absolute path in Windows \n        - distro: Name of the WSL distribution (default 'Ubuntu')\n\n        \"\"\"\n        # Paso 1: Convertir la ruta de origen de Linux a Windows usando wslpath\n        try:\n            result = subprocess.run(\n                [\"wsl\", \"-d\", distro, \"wslpath\", \"-w\", origin],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n            origin_win = result.stdout.strip()\n            if not origin_win:\n                raise RuntimeError(\"La conversi\u00f3n de ruta no devolvi\u00f3 resultado.\")\n        except subprocess.CalledProcessError as e:\n            raise RuntimeError(f\"Error ejecutando wslpath: {e.stderr.strip()}\") from e\n        except Exception as e:\n            raise RuntimeError(f\"Error inesperado al convertir la ruta: {e}\") from e\n\n        # Paso 2: Verificar que el archivo existe en la ruta de Windows\n        if not os.path.isfile(origin_win):\n            raise FileNotFoundError(f\"El archivo de origen no existe: {origin_win}\")\n\n        # Paso 3: Copiar el archivo al destino en Windows\n        try:\n            shutil.copy2(origin_win, dest)\n            return True\n        except Exception as e:\n            raise RuntimeError(f\"Error copiando el archivo: {e}\") from e\n\n\n    def wsl_backup(self, dest, distro=\"Ubuntu\"):\n        cmd = f\"wsl --export {distro} {dest})\"\n\n        process = subprocess.Popen(\n            cmd,\n            shell=True,\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL\n        )\n        return process\n\n    # ========================\n    # Funciones de red\n    # ========================\n\n\n    def get_wsl_ip(self):\n        \"\"\"\n        Gets current IP.\n        If distro_name is None, uses defautl.\n        \"\"\"\n        if self.distro:\n            cmd = f\"wsl -d {self.distro} hostname -I\"\n        else:\n            cmd = \"wsl hostname -I\"\n        result = subprocess.run(cmd, capture_output=True, text=True, shell=True)\n        ip = result.stdout.strip().split()[0]  # Primer IPa devuelta\n        return ip\n</code></pre>"},{"location":"#wsl.WSL.configure_distribution","title":"<code>configure_distribution(default_uid=None, flags=None)</code>","text":"<p>Configure the WSL distribution parameters</p> <p>Parameters:</p> Name Type Description Default <code>default_uid</code> <code>int</code> <p>Default user UID</p> <code>None</code> <code>flags</code> <code>WSL_DISTRIBUTION_FLAGS</code> <p>Configuration flags</p> <code>None</code> Source code in <code>wsl.py</code> <pre><code>def configure_distribution(self, \n                         default_uid: int = None, \n                         flags: WSL_DISTRIBUTION_FLAGS = None):\n    \"\"\"\n\n    Configure the WSL distribution parameters\n\n\n    Args:\n        default_uid (int): Default user UID\n        flags (WSL_DISTRIBUTION_FLAGS): Configuration flags\n\n    \"\"\"\n    current_config = self.get_distribution_configuration()\n\n    # Mantener valores actuales si no se especifican\n    final_uid = default_uid if default_uid is not None else current_config['default_uid']\n    final_flags = flags if flags is not None else current_config['flags']\n\n    hr = self.wslapi.WslConfigureDistribution(\n        self.distro,\n        final_uid,\n        final_flags.value if isinstance(final_flags, WSL_DISTRIBUTION_FLAGS) else final_flags\n    )\n\n    return hr == 0\n</code></pre>"},{"location":"#wsl.WSL.copy_from_wsl","title":"<code>copy_from_wsl(origin, dest, distro='Ubuntu')</code>","text":"<p>Copies a file from a path in WSL (origin, Linux) to a destination path in Windows (dest). - origin: Absolute path in Linux (e.g., /home/user/file.txt) - dest: Absolute path in Windows  - distro: Name of the WSL distribution (default 'Ubuntu')</p> Source code in <code>wsl.py</code> <pre><code>def copy_from_wsl(self, origin, dest, distro=\"Ubuntu\"):\n    \"\"\"\n    Copies a file from a path in WSL (origin, Linux) to a destination path in Windows (dest).\n    - origin: Absolute path in Linux (e.g., /home/user/file.txt)\n    - dest: Absolute path in Windows \n    - distro: Name of the WSL distribution (default 'Ubuntu')\n\n    \"\"\"\n    # Paso 1: Convertir la ruta de origen de Linux a Windows usando wslpath\n    try:\n        result = subprocess.run(\n            [\"wsl\", \"-d\", distro, \"wslpath\", \"-w\", origin],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        origin_win = result.stdout.strip()\n        if not origin_win:\n            raise RuntimeError(\"La conversi\u00f3n de ruta no devolvi\u00f3 resultado.\")\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Error ejecutando wslpath: {e.stderr.strip()}\") from e\n    except Exception as e:\n        raise RuntimeError(f\"Error inesperado al convertir la ruta: {e}\") from e\n\n    # Paso 2: Verificar que el archivo existe en la ruta de Windows\n    if not os.path.isfile(origin_win):\n        raise FileNotFoundError(f\"El archivo de origen no existe: {origin_win}\")\n\n    # Paso 3: Copiar el archivo al destino en Windows\n    try:\n        shutil.copy2(origin_win, dest)\n        return True\n    except Exception as e:\n        raise RuntimeError(f\"Error copiando el archivo: {e}\") from e\n</code></pre>"},{"location":"#wsl.WSL.copy_to_wsl","title":"<code>copy_to_wsl(origin, dest, distro='Ubuntu')</code>","text":"<p>Copies a Windows file (origin) to a destination path (dest) in the specified WSL distribution. - origin: Absolute path in Windows  - dest: Absolute path in Linux (e.g., /home/user/file.txt) - distro: Name of the WSL distribution (default 'Ubuntu')</p> Source code in <code>wsl.py</code> <pre><code>def copy_to_wsl(self, origin, dest, distro=\"Ubuntu\"):\n    \"\"\"\n    Copies a Windows file (origin) to a destination path (dest) in the specified WSL distribution.\n    - origin: Absolute path in Windows \n    - dest: Absolute path in Linux (e.g., /home/user/file.txt)\n    - distro: Name of the WSL distribution (default 'Ubuntu')\n\n    \"\"\"\n    #Paso 1: Convertir la ruta destino de Linux a ruta Windows usando wslpath\n    print(dest)\n    try:\n         result = subprocess.run(\n             [\"wsl\", \"-d\", distro, \"wslpath\", \"-w\", dest],\n             capture_output=True,\n             text=True,\n             check=True\n         )\n         dest_win = result.stdout.strip()\n         if not dest:\n             raise RuntimeError(\"La conversi\u00f3n de ruta\u00ba no devolvi\u00f3 resultado.\")\n    except subprocess.CalledProcessError as e:\n         raise RuntimeError(f\"Error ejecutando wslpath: {e.stderr.strip()}\") from e\n    except Exception as e:\n         raise RuntimeError(f\"Error inesperado al convertir la ruta: {e}\") from e\n\n\n\n    # Paso 3: Copiar el archivo\n    try:\n        shutil.copy2(origin, dest_win)\n\n        return True\n    except Exception as e:\n        raise RuntimeError(f\"Error copiando el archivo: {e}\") from e\n</code></pre>"},{"location":"#wsl.WSL.get_automount_settings","title":"<code>get_automount_settings()</code>","text":"<p>Returns mount config</p> Source code in <code>wsl.py</code> <pre><code>def get_automount_settings(self):\n    \"\"\"Returns mount config\"\"\"\n    conf = self.parse_wsl_conf()\n    return {\n        'enabled': conf.get('automount', {}).get('enabled', True),\n        'root': conf.get('automount', {}).get('root', '/mnt'),\n        'options': conf.get('automount', {}).get('options', '')\n    }\n</code></pre>"},{"location":"#wsl.WSL.get_default_user","title":"<code>get_default_user()</code>","text":"<p>Returns default user</p> Source code in <code>wsl.py</code> <pre><code>def get_default_user(self):\n    \"\"\"Returns default user\"\"\"\n    return self.parse_wsl_conf().get('user', {}).get('default')\n</code></pre>"},{"location":"#wsl.WSL.get_network_config","title":"<code>get_network_config()</code>","text":"<p>Returns network configuration in dict format</p> Source code in <code>wsl.py</code> <pre><code>def get_network_config(self):\n    \"\"\"Returns network configuration in dict format\"\"\"\n    conf = self.parse_wsl_conf()\n    return {\n        'hostname': conf.get('network', {}).get('hostname'),\n        'generate_hosts': conf.get('network', {}).get('generatehosts', True),\n        'generate_resolvconf': conf.get('network', {}).get('generateresolvconf', True)\n    }\n</code></pre>"},{"location":"#wsl.WSL.get_wsl_distro_info_by_name","title":"<code>get_wsl_distro_info_by_name()</code>","text":"<p>Returns a dictionary with the requested data for the WSL distribution whose name matches distro_name. If not found, returns None.</p> Source code in <code>wsl.py</code> <pre><code>def get_wsl_distro_info_by_name(self):\n    \"\"\"\n    Returns a dictionary with the requested data for the WSL distribution whose name matches distro_name.\n    If not found, returns None.\n    \"\"\"\n    key_path = r\"Software\\Microsoft\\Windows\\CurrentVersion\\Lxss\"\n    fields = [\"BasePath\", \"Flavor\", \"PackageFamilyName\", \"Version\", \"osVersion\"]\n    try:\n        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, key_path) as lxss_key:\n            i = 0\n            while True:\n                try:\n                    guid = winreg.EnumKey(lxss_key, i)\n                    with winreg.OpenKey(lxss_key, guid) as distro_key:\n                        try:\n                            name = winreg.QueryValueEx(distro_key, \"DistributionName\")[0]\n                        except FileNotFoundError:\n                            name = None\n                        if isinstance(name, str) and name.lower() == self.distro.lower():\n                            result = {\n                                \"BasePath\": None,\n                                \"Flavor\": None,\n                                \"GUID\": guid,\n                                \"osVersion\": None,\n                                \"PackageFamilyName\": None\n                            }\n                            for field in fields:\n                                try:\n                                    value = winreg.QueryValueEx(distro_key, field)[0]\n                                    if field.lower() in (\"version\", \"osversion\"):\n                                        result[\"osVersion\"] = value\n                                    else:\n                                        result[field] = value\n                                except FileNotFoundError:\n                                    continue\n                            return result\n                    i += 1\n                except OSError:\n                    break\n    except Exception as e:\n        print(f\"Error accediendo al registro: {e}\")\n    return None\n</code></pre>"},{"location":"#wsl.WSL.get_wsl_ip","title":"<code>get_wsl_ip()</code>","text":"<p>Gets current IP. If distro_name is None, uses defautl.</p> Source code in <code>wsl.py</code> <pre><code>def get_wsl_ip(self):\n    \"\"\"\n    Gets current IP.\n    If distro_name is None, uses defautl.\n    \"\"\"\n    if self.distro:\n        cmd = f\"wsl -d {self.distro} hostname -I\"\n    else:\n        cmd = \"wsl hostname -I\"\n    result = subprocess.run(cmd, capture_output=True, text=True, shell=True)\n    ip = result.stdout.strip().split()[0]  # Primer IPa devuelta\n    return ip\n</code></pre>"},{"location":"#wsl.WSL.install_package","title":"<code>install_package(package, password)</code>","text":"<p>Install a package using sudo</p> Source code in <code>wsl.py</code> <pre><code>def install_package(self, package, password):\n    \"\"\"Install a package using sudo\"\"\"\n    return self.run_command(\n        f\"sudo -S apt-get install -y {package}\",\n        input=f\"{password}\\n\",\n        shell=False\n    )\n</code></pre>"},{"location":"#wsl.WSL.is_distribution_registered","title":"<code>is_distribution_registered(distribution_name)</code>","text":"<p>Checks if a distribution is registered.</p> <p>Args: distribution_name: Name of the distribution to check</p> <p>Returns: bool: True if the distribution is registered</p> Source code in <code>wsl.py</code> <pre><code>def is_distribution_registered(self, distribution_name: str) -&gt; bool:\n    \"\"\"\n    Checks if a distribution is registered.\n\n    Args:\n    distribution_name: Name of the distribution to check\n\n    Returns:\n    bool: True if the distribution is registered\n    \"\"\"\n    return bool(self.wslapi.WslIsDistributionRegistered(distribution_name))\n</code></pre>"},{"location":"#wsl.WSL.is_interop_enabled","title":"<code>is_interop_enabled()</code>","text":"<p>Returns True if interoperatibility is enabled</p> Source code in <code>wsl.py</code> <pre><code>def is_interop_enabled(self):\n    \"\"\"Returns True if interoperatibility is enabled\"\"\"\n    conf = self.parse_wsl_conf()\n    return conf.get('interop', {}).get('enabled', True)  \n</code></pre>"},{"location":"#wsl.WSL.is_systemd_enabled","title":"<code>is_systemd_enabled()</code>","text":"<p>Returns True if systemd is enabled</p> Source code in <code>wsl.py</code> <pre><code>def is_systemd_enabled(self):\n    \"\"\"Returns True if systemd is enabled\"\"\"\n    conf = self.parse_wsl_conf()\n    return conf.get('systemd', {}).get('enabled', True)  \n</code></pre>"},{"location":"#wsl.WSL.is_useWindowsTimezone_enabled","title":"<code>is_useWindowsTimezone_enabled()</code>","text":"<p>Returns True if useWindowsTimezone is enabled</p> Source code in <code>wsl.py</code> <pre><code>def is_useWindowsTimezone_enabled(self):\n    \"\"\"Returns True if useWindowsTimezone is enabled\"\"\"\n    conf = self.parse_wsl_conf()\n    return conf.get('useWindowsTimezone', {}).get('enabled', True)  \n</code></pre>"},{"location":"#wsl.WSL.launch","title":"<code>launch(command, capture_output=True)</code>","text":"<p>Execute a command using the native api</p> Source code in <code>wsl.py</code> <pre><code>def launch(self, command: str, capture_output: bool = True) -&gt; dict:\n    \"\"\"Execute a command using the native api\"\"\"\n    result = self._launch_process(command)\n    return {\n        \"stdout\": result[\"stdout\"].decode(\"utf-8\", errors=\"replace\") if capture_output else \"\",\n        \"stderr\": result[\"stderr\"].decode(\"utf-8\", errors=\"replace\") if capture_output else \"\",\n        \"exit_code\": result[\"exit_code\"]\n    }\n</code></pre>"},{"location":"#wsl.WSL.launch_interactive","title":"<code>launch_interactive(command=None, use_current_working_directory=True)</code>","text":"<p>Ejecuta un comando interactivo usando WslLaunchInteractive.</p> <pre><code>Args:\n    command (str, optional): Command to execute. If None, launches the default shell.\n    use_current_working_directory (bool): Use the current working directory of the calling process.\n\nReturns:\n    dict: {\n    \"hr\": HRESULT,\n    \"exit_code\": int (only if hr == 0)\n    }\n</code></pre> Source code in <code>wsl.py</code> <pre><code>def launch_interactive(self, command: str = None, use_current_working_directory: bool = True) -&gt; dict:\n    \"\"\"\n    Ejecuta un comando interactivo usando WslLaunchInteractive.\n\n        Args:\n            command (str, optional): Command to execute. If None, launches the default shell.\n            use_current_working_directory (bool): Use the current working directory of the calling process.\n\n        Returns:\n            dict: {\n            \"hr\": HRESULT,\n            \"exit_code\": int (only if hr == 0)\n            }\n    \"\"\"\n    exit_code = wintypes.DWORD()\n\n    hr = self.wslapi.WslLaunchInteractive(\n        self.distro,\n        command,\n        use_current_working_directory,\n        ctypes.byref(exit_code)\n    )\n\n    return {\n        \"hr\": hr,\n        \"exit_code\": exit_code.value if hr == 0 else None\n    }\n</code></pre>"},{"location":"#wsl.WSL.list_installed_packages","title":"<code>list_installed_packages()</code>","text":"<p>List installed packages</p> Source code in <code>wsl.py</code> <pre><code>def list_installed_packages(self):\n    \"\"\"List installed packages\"\"\"\n    commands = [\n    (\"apt\", \"apt list\"),\n    (\"dnf\", \"dnf list installed\"),\n    (\"yum\", \"yum list installed\"),\n    (\"zypper\", \"zypper se --installed-only\"),\n]\n    for name, cmd in commands:\n    # Verifica si el gestor de paquetes est\u00e1 disponible\n        check = self.run_command(f\"which {name}\")\n        if isinstance(check, dict):\n            found = bool(check.get('stdout', '').strip())\n        else:\n            found = bool(check.strip())\n        if not found:\n            continue  # El gestor no est\u00e1 presente, prueba el siguiente\n\n        # Ejecuta el comando para listar paquetes\n        result = self.run_command(cmd)\n        output = result.get('stdout', '') if isinstance(result, dict) else result\n        if output:\n            return output.splitlines()\n\n    # Si ninguno est\u00e1 disponible, retorna una lista vac\u00eda\n    return []\n</code></pre>"},{"location":"#wsl.WSL.parse_wslconfig","title":"<code>parse_wslconfig()</code>","text":"<p>Analyzes .wslconfig and return dictionary</p> Source code in <code>wsl.py</code> <pre><code>def parse_wslconfig(self):\n    \"\"\"Analyzes .wslconfig and return dictionary\"\"\"\n    raw_content = self.read_wslconfig()  # Debe devolver el texto plano del archivo\n    config = {\n        'wsl2': {}\n    }\n    current_section = None\n    for line in raw_content.split('\\n'):\n        line = line.strip()\n        if line.startswith('#') or not line:\n            continue\n        if line.startswith('[') and line.endswith(']'):\n            current_section = line[1:-1].lower()\n            continue\n        if '=' in line and current_section:\n            key, value = line.split('=', 1)\n            key = key.strip().lower()\n            value = value.strip()\n            # Convertir booleanos\n            if value.lower() in ('true', 'false'):\n                value = value.lower() == 'true'\n            # Convertir n\u00fameros si corresponde\n            elif value.isdigit():\n                value = int(value)\n            if current_section in config:\n                config[current_section][key] = value\n    return config\n</code></pre>"},{"location":"#wsl.WSL.read_wsl_conf","title":"<code>read_wsl_conf(output_format='raw')</code>","text":"<p>Reads /etc/wsl.conf</p> Source code in <code>wsl.py</code> <pre><code>def read_wsl_conf(self, output_format='raw'):\n    \"\"\"Reads /etc/wsl.conf\"\"\"\n    return self._launch_process(\"cat /etc/wsl.conf\")\n</code></pre>"},{"location":"#wsl.WSL.read_wslconfig","title":"<code>read_wslconfig()</code>","text":"<p>Read .wslconfig</p> Source code in <code>wsl.py</code> <pre><code>def read_wslconfig(self):\n    \"\"\"Read .wslconfig\"\"\"\n    path = os.path.expanduser(\"~/.wslconfig\")\n\n    try:\n        with open(path, \"r\") as f:\n            return f.read()\n    except Exception as e:\n        print(f\"Error leyendo {path}: {e}\")\n        return None\n</code></pre>"},{"location":"#wsl.WSL.register_distribution","title":"<code>register_distribution(distribution_name, tar_gz_path)</code>","text":"<p>Register a new WSL distribution.</p> <p>Args:  distribution_name: Unique name of the distribution (e.g., \"MyDistro\")  tar_gz_path: Full path to the .tar.gz file containing the filesystem</p> <p>Returns:  bool: True if registration was successful, False if it faileda</p> Source code in <code>wsl.py</code> <pre><code>def register_distribution(self, distribution_name: str, tar_gz_path: str) -&gt; bool:\n    \"\"\"\n   Register a new WSL distribution.\n\n    Args:\n    distribution_name: Unique name of the distribution (e.g., \"MyDistro\")\n    tar_gz_path: Full path to the .tar.gz file containing the filesystem\n\n    Returns:\n    bool: True if registration was successful, False if it faileda\n    \"\"\"\n    hr = self.wslapi.WslRegisterDistribution(distribution_name, tar_gz_path)\n    return hr == 0  # S_OK = 0\n</code></pre>"},{"location":"#wsl.WSL.run_command","title":"<code>run_command(command, capture_output=True, shell=False, input=None)</code>","text":"<p>Execute a command using subprocess</p> Source code in <code>wsl.py</code> <pre><code>def run_command(self, command, capture_output=True, shell=False,input=None):\n    \"\"\"Execute a command using subprocess\"\"\"\n    base_cmd = ['wsl.exe', '-d', self.distro]\n\n    try:\n        if shell:\n            full_cmd = base_cmd + ['/bin/bash', '-c', command]\n            args = ' '.join(full_cmd)\n            print(full_cmd)\n        else:\n            args = base_cmd + shlex.split(command)\n            print(command)\n\n        result = subprocess.run(\n            args,\n            input=input,\n            capture_output=capture_output,\n            text=True,\n            check=True,\n            shell=False\n        )\n\n        return {\n            \"stdout\": result.stdout,\n            \"stderr\": result.stderr,\n            \"exit_code\": result.returncode,\n\n        }\n\n    except subprocess.CalledProcessError as e:\n        return {\n            \"stdout\": e.stdout,\n            \"stderr\": e.stderr,\n            \"exit_code\": e.returncode\n        }\n</code></pre>"},{"location":"#wsl.WSL.set_distribution_flag","title":"<code>set_distribution_flag(flag, enable)</code>","text":"<p>\"Modify a specific flag while keeping the others unchanged</p> Source code in <code>wsl.py</code> <pre><code>def set_distribution_flag(self, flag: WSL_DISTRIBUTION_FLAGS, enable: bool):\n    \"\"\"\"Modify a specific flag while keeping the others unchanged\"\"\"\n    config = self.get_distribution_configuration()\n    if not config:\n        return False\n\n    current_flags = config['flags']\n\n    if enable:\n        new_flags = current_flags | flag\n    else:\n        new_flags = current_flags &amp; ~flag\n\n    return self.configure_distribution(flags=new_flags)\n</code></pre>"},{"location":"#wsl.WSL.unregister_distribution","title":"<code>unregister_distribution(distribution_name)</code>","text":"<p>Unregister a WSL distribution.</p> <p>Parameters:</p> Name Type Description Default <code>distribution_name</code> <code>str</code> <p>Name of the distribution to remove</p> required <p>Returns:     bool: True if the operation was successful</p> Source code in <code>wsl.py</code> <pre><code>def unregister_distribution(self, distribution_name: str) -&gt; bool:\n    \"\"\"\n    Unregister a WSL distribution.\n\n    Args:\n        distribution_name: Name of the distribution to remove\n    Returns:\n        bool: True if the operation was successful\n    \"\"\"\n    hr = self.wslapi.WslUnregisterDistribution(distribution_name)\n    return hr == 0  # S_OK = 0\n</code></pre>"},{"location":"#wsl.WSL.wsl2_gui_applications","title":"<code>wsl2_gui_applications()</code>","text":"<p>Devuelve True/False seg\u00fan la opci\u00f3n guiApplications de WSL2</p> Source code in <code>wsl.py</code> <pre><code>def wsl2_gui_applications(self):\n    \"\"\"Devuelve True/False seg\u00fan la opci\u00f3n guiApplications de WSL2\"\"\"\n    conf = self.parse_wslconfig()\n    return conf.get('wsl2', {}).get('guiapplications', True)  # True por defecto\n</code></pre>"},{"location":"#wsl.WSL.wsl2_localhost_forwarding","title":"<code>wsl2_localhost_forwarding()</code>","text":"<p>Returns True/False for localhostForwarding in WSL2</p> Source code in <code>wsl.py</code> <pre><code>def wsl2_localhost_forwarding(self):\n    \"\"\"Returns True/False for localhostForwarding in WSL2\"\"\"\n    conf = self.parse_wslconfig()\n    return conf.get('wsl2', {}).get('localhostforwarding', True)  # True por defecto\n</code></pre>"},{"location":"#wsl.WSL.wsl2_memory","title":"<code>wsl2_memory()</code>","text":"<p>Returns memory limit in WSL2 or None</p> Source code in <code>wsl.py</code> <pre><code>def wsl2_memory(self):\n    \"\"\"Returns memory limit in WSL2 or None\"\"\"\n    conf = self.parse_wslconfig()\n    return conf.get('wsl2', {}).get('memory')\n</code></pre>"},{"location":"#wsl.WSL.wsl2_processors","title":"<code>wsl2_processors()</code>","text":"<p>Returns processors in WSL2 o None</p> Source code in <code>wsl.py</code> <pre><code>def wsl2_processors(self):\n    \"\"\"Returns processors in WSL2 o None\"\"\"\n    conf = self.parse_wslconfig()\n    return conf.get('wsl2', {}).get('processors')\n</code></pre>"},{"location":"#wsl.WSL.wsl2_swap","title":"<code>wsl2_swap()</code>","text":"<p>Returns swap size in WSL2 o None</p> Source code in <code>wsl.py</code> <pre><code>def wsl2_swap(self):\n    \"\"\"Returns swap size in WSL2 o None\"\"\"\n    conf = self.parse_wslconfig()\n    return conf.get('wsl2', {}).get('swap')\n</code></pre>"}]}